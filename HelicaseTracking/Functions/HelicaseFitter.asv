function [ helicaseFitter ] = HelicaseFitter( config, simulateImages )
    %Helicase Fitter: Fits a gaussian for the different helicases
    % We can use the CLEAN algorithm for this purpose,just with a higher threshold :)
        % CLEAN Algorithm
    % 1. Find brightest pixel in each image, extract nearby patch
    % 2. Fit 2D Gaussian to the patch (use gaussMLEv2)
    % 3. Generate Gaussian mask from fitting parameters and substract from
    %    original image (IF fit has failed replace with background intensity)
    % 4. Repeat 1-3 until a treshold is reached

    
    N=config.numFrames;
    
    for i=1:N
        helicaseFitter.brightFinder=BrightFinder( config, simulateImages.simulateHelicases.image{i} );
        helicaseFitter.A(:,:,i)= helicaseFitter.brightFinder.matrix;
    end

    
    Nfits=N         %number of images to fit
    bg=0;           %background fluorescence in photons/pixel/frame
    Nphotons=250;   %expected photons/frame
    Npixels=7;      %linear size of fit region in pixels. 
    PSFsigma=1;     %PSF sigma in pixels
    fittype=1;

    %   Generate a stack of images
    coords=Npixels/2-1+rand([Nfits 2])+[0*ones(Nfits,1) zeros(Nfits,1)];
    [out] = finitegausspsf(Npixels,PSFsigma,Nphotons,bg,coords);

    %   Corrupt with Poisson noise 
    data=single(noise(out,'poisson',1)); %requires DipImage
    %data = poissrnd(out); %requires statistics toolbox
    %   Can look at data (DipImage)
    %dipshow(permute(data,[2 1 3])); %dipimage permuted 1st two dimensions

    iterations=5;

    %   Fit and calculate speed
    [P CRLB LL t]=gaussmlev2(data,PSFsigma,iterations,fittype);
end

